-- Olho Emocional Premium Avançado
-- Versão 2.0 - Com inteligência emocional e efeitos visuais melhorados

-- Configuração inicial
local mon = peripheral.find("monitor") or peripheral.find("advanced_monitor")
if not mon then
    print("Nenhum monitor compatível encontrado!")
    return
end

mon.setTextScale(0.5)
local w, h = mon.getSize()
local centerX, centerY = math.floor(w / 2), math.floor(h / 2)

-- Sistema de configuração modular
local config = {
    debugMode = false,
    maxFPS = 30,
    smoothBlinking = true,
    enablePhysics = true,
    colorTransitionSpeed = 0.05,
    emotionChangeInterval = {min=5, max=15}, -- em segundos
    eye = {
        baseWidth = 30,
        baseHeight = 20,
        irisWidth = 16,
        irisHeight = 12,
        pupilBaseSize = 3,
        scleraColor = colors.white
    },
    palette = {
        emotions = {
            NORMAL = {base=colors.white, highlight=colors.lightGray},
            ANGRY = {base=colors.red, highlight=colors.orange},
            HAPPY = {base=colors.lime, highlight=colors.yellow},
            SAD = {base=colors.blue, highlight=colors.lightBlue},
            SCARED = {base=colors.purple, highlight=colors.magenta},
            SURPRISED = {base=colors.yellow, highlight=colors.white}
        },
        veins = {colors.red, colors.darkRed},
        tears = {colors.lightBlue, colors.blue, colors.cyan}
    },
    emotions = {
        NORMAL = {
            blinkRate = {min=0.005, max=0.01},
            pupilSize = 1.0,
            movement = {speed=0.1, range=0.5},
            bgEffect = "none"
        },
        ANGRY = {
            blinkRate = {min=0.01, max=0.02},
            pupilSize = 0.8,
            movement = {speed=0.2, range=0.3, jitter=0.1},
            bgEffect = "pulseRed",
            veins = true,
            veinIntensity = 0.7
        },
        HAPPY = {
            blinkRate = {min=0.003, max=0.008},
            pupilSize = 1.2,
            movement = {speed=0.08, range=0.6},
            bgEffect = "sparkle"
        },
        SAD = {
            blinkRate = {min=0.01, max=0.015},
            pupilSize = 1.3,
            movement = {speed=0.05, range=0.4},
            bgEffect = "rain",
            tearful = true,
            tearRate = 0.1
        },
        SCARED = {
            blinkRate = {min=0.02, max=0.04},
            pupilSize = 0.5,
            movement = {speed=0.3, range=0.8, jitter=0.3},
            bgEffect = "static",
            shakeIntensity = 0.5
        },
        SURPRISED = {
            blinkRate = {min=0.001, max=0.003},
            pupilSize = 1.5,
            movement = {speed=0.05, range=0.2},
            bgEffect = "glow",
            eyeOpenness = 1.2
        }
    },
    effects = {
        none = {
            update = function() end,
            draw = function() end
        },
        pulseRed = {
            intensity = 0,
            speed = 0.07,
            update = function(self)
                self.intensity = (self.intensity + self.speed) % (math.pi * 2)
            end,
            draw = function(self)
                local pulse = math.floor((math.sin(self.intensity) + 1) * 3)
                for y = -h/2, h/2 do
                    for x = -w/2, w/2 do
                        local dist = math.sqrt(x*x + y*y)
                        if dist > math.max(w,h)/2 + 2 and dist < math.max(w,h)/2 + 2 + pulse then
                            mon.setBackgroundColor(colors.red)
                            mon.setCursorPos(centerX + x, centerY + y)
                            mon.write(" ")
                        end
                    end
                end
            end
        },
        sparkle = {
            particles = {},
            update = function(self)
                -- Adicionar novas partículas
                if #self.particles < 50 and math.random() < 0.3 then
                    table.insert(self.particles, {
                        x = math.random(-w, w),
                        y = math.random(-h, h),
                        life = math.random(10, 30),
                        speed = math.random(1, 3),
                        color = math.random() < 0.7 and colors.yellow or colors.white
                    })
                end
                
                -- Atualizar partículas existentes
                for i = #self.particles, 1, -1 do
                    local p = self.particles[i]
                    p.life = p.life - 1
                    p.y = p.y - p.speed
                    if p.life <= 0 then
                        table.remove(self.particles, i)
                    end
                end
            end,
            draw = function(self)
                for _, p in ipairs(self.particles) do
                    local dist = math.sqrt(p.x*p.x + p.y*p.y)
                    if dist > math.max(w,h)/2 + 1 then
                        mon.setBackgroundColor(p.color)
                        mon.setCursorPos(centerX + p.x, centerY + p.y)
                        mon.write(" ")
                    end
                end
            end
        },
        rain = {
            drops = {},
            update = function(self)
                -- Adicionar novas gotas
                if #self.drops < 30 or math.random() < 0.2 then
                    table.insert(self.drops, {
                        x = math.random(-w, w),
                        y = -h/2 - 5,
                        speed = math.random(2, 5),
                        size = math.random(1, 2),
                        bright = math.random() < 0.3
                    })
                end
                
                -- Mover gotas
                for i = #self.drops, 1, -1 do
                    local d = self.drops[i]
                    d.y = d.y + d.speed
                    if d.y > h/2 + 5 then
                        table.remove(self.drops, i)
                    end
                end
            end,
            draw = function(self)
                for _, d in ipairs(self.drops) do
                    local dist = math.sqrt(d.x*d.x + d.y*d.y)
                    if dist > math.max(w,h)/2 + 1 then
                        local color = d.bright and colors.lightBlue or colors.blue
                        mon.setBackgroundColor(color)
                        for i = 0, d.size do
                            mon.setCursorPos(centerX + d.x, centerY + d.y + i)
                            mon.write(" ")
                        end
                    end
                end
            end
        },
        static = {
            noise = {},
            update = function(self)
                -- Gerar novo ruído
                self.noise = {}
                for i = 1, math.random(30, 70) do
                    table.insert(self.noise, {
                        x = math.random(-w, w),
                        y = math.random(-h, h),
                        intensity = math.random()
                    })
                end
            end,
            draw = function(self)
                for _, n in ipairs(self.noise) do
                    local dist = math.sqrt(n.x*n.x + n.y*n.y)
                    if dist > math.max(w,h)/2 + 1 then
                        local color = n.intensity > 0.7 and colors.white
                                     or n.intensity > 0.4 and colors.lightGray
                                     or colors.gray
                        mon.setBackgroundColor(color)
                        mon.setCursorPos(centerX + n.x, centerY + n.y)
                        mon.write(" ")
                    end
                end
            end
        },
        glow = {
            intensity = 0,
            direction = 1,
            update = function(self)
                self.intensity = self.intensity + self.direction * 0.05
                if self.intensity >= 1 then
                    self.direction = -1
                elseif self.intensity <= 0 then
                    self.direction = 1
                end
            end,
            draw = function(self)
                local radius = math.max(w,h)/2 + math.floor(self.intensity * 5)
                for y = -h/2, h/2 do
                    for x = -w/2, w/2 do
                        local dist = math.sqrt(x*x + y*y)
                        if dist > math.max(w,h)/2 and dist < radius then
                            local fade = 1 - (dist - math.max(w,h)/2) / (radius - math.max(w,h)/2)
                            mon.setBackgroundColor(colors.yellow)
                            mon.setCursorPos(centerX + x, centerY + y)
                            mon.write(" ")
                        end
                    end
                end
            end
        }
    }
}

-- Sistema de estado do olho
local eye = {
    currentEmotion = "NORMAL",
    targetEmotion = "NORMAL",
    emotionTransition = 0,
    emotionTimer = 0,
    
    physicalState = {
        openness = 1.0,    -- 0.0 (fechado) a 1.0 (aberto)
        blinkProgress = 0,  -- 0.0 a 1.0
        isBlinking = false,
        
        pupilSize = 1.0,
        targetPupilSize = 1.0,
        
        lookX = 0,
        lookY = 0,
        targetLookX = 0,
        targetLookY = 0,
        
        shakeOffsetX = 0,
        shakeOffsetY = 0,
        
        color = colors.white,
        targetColor = colors.white,
        colorProgress = 0
    },
    
    particles = {
        tears = {},
        veins = {},
        sparkles = {}
    },
    
    effects = {
        current = config.effects.none,
        next = config.effects.none,
        transition = 0
    },
    
    stats = {
        frameCount = 0,
        lastFPS = 0,
        lastUpdate = 0
    }
}

-- Inicializar partículas
for i = 1, 100 do
    eye.particles.tears[i] = {
        x = 0, y = 0,
        speed = 0,
        size = 1,
        life = 0,
        active = false
    }
end

for i = 1, 50 do
    eye.particles.veins[i] = {
        x1 = math.random(-28, 28),
        y1 = math.random(-18, 18),
        x2 = math.random(-28, 28),
        y2 = math.random(-18, 18),
        width = math.random(1, 3),
        pulse = math.random()
    }
end

-- Funções auxiliares
local function lerp(a, b, t)
    return a + (b - a) * math.min(1, math.max(0, t))
end

local function easeInOutQuad(t)
    if t < 0.5 then return 2 * t * t end
    return -1 + (4 - 2 * t) * t
end

local function setEmotion(newEmotion, immediate)
    if not config.emotions[newEmotion] then return end
    
    if immediate then
        eye.currentEmotion = newEmotion
        eye.targetEmotion = newEmotion
        eye.emotionTransition = 0
        eye.physicalState.targetColor = config.palette.emotions[newEmotion].base
        eye.physicalState.targetPupilSize = config.emotions[newEmotion].pupilSize
        eye.effects.next = config.effects[config.emotions[newEmotion].bgEffect]
        eye.effects.transition = 1
    else
        eye.targetEmotion = newEmotion
        eye.emotionTransition = 0
    end
    
    -- Definir temporizador para próxima mudança de emoção
    eye.emotionTimer = math.random(
        config.emotionChangeInterval.min * 20,
        config.emotionChangeInterval.max * 20
    )
end

local function triggerBlink()
    if not eye.physicalState.isBlinking then
        eye.physicalState.isBlinking = true
        eye.physicalState.blinkProgress = 0
    end
end

local function updateBlink(dt)
    if eye.physicalState.isBlinking then
        eye.physicalState.blinkProgress = eye.physicalState.blinkProgress + dt * 5
        if eye.physicalState.blinkProgress >= 1 then
            eye.physicalState.isBlinking = false
            eye.physicalState.blinkProgress = 0
        end
    end
    
    -- Piscar baseado na emoção atual
    local emotion = config.emotions[eye.currentEmotion]
    if not eye.physicalState.isBlinking and math.random() < emotion.blinkRate.max then
        triggerBlink()
    end
end

local function updateEyeMovement(dt)
    local emotion = config.emotions[eye.currentEmotion]
    
    -- Atualizar direção do olhar
    if math.random() < 0.05 then
        local range = emotion.movement.range or 0.5
        local jitter = emotion.movement.jitter or 0
        eye.physicalState.targetLookX = (math.random() * 2 - 1) * range + (math.random() * 2 - 1) * jitter
        eye.physicalState.targetLookY = (math.random() * 2 - 1) * range * 0.6 + (math.random() * 2 - 1) * jitter
    end
    
    -- Suavizar movimento do olhar
    local speed = emotion.movement.speed or 0.1
    eye.physicalState.lookX = lerp(eye.physicalState.lookX, eye.physicalState.targetLookX, speed)
    eye.physicalState.lookY = lerp(eye.physicalState.lookY, eye.physicalState.targetLookY, speed)
    
    -- Tremor para emoções como MEDO
    if emotion.shakeIntensity then
        eye.physicalState.shakeOffsetX = (math.random() * 2 - 1) * emotion.shakeIntensity
        eye.physicalState.shakeOffsetY = (math.random() * 2 - 1) * emotion.shakeIntensity
    else
        eye.physicalState.shakeOffsetX = 0
        eye.physicalState.shakeOffsetY = 0
    end
end

local function updateEmotionTransition(dt)
    if eye.currentEmotion ~= eye.targetEmotion then
        eye.emotionTransition = eye.emotionTransition + dt * 0.5
        if eye.emotionTransition >= 1 then
            eye.currentEmotion = eye.targetEmotion
            eye.emotionTransition = 0
            eye.effects.next = config.effects[config.emotions[eye.currentEmotion].bgEffect]
            eye.effects.transition = 0
        end
    end
    
    -- Atualizar transição de cor
    local targetColor = config.palette.emotions[eye.targetEmotion].base
    if eye.physicalState.targetColor ~= targetColor then
        eye.physicalState.targetColor = targetColor
        eye.physicalState.colorProgress = 0
    end
    
    if eye.physicalState.colorProgress < 1 then
        eye.physicalState.colorProgress = eye.physicalState.colorProgress + config.colorTransitionSpeed
        local r1, g1, b1 = colors.unpack(eye.physicalState.color)
        local r2, g2, b2 = colors.unpack(eye.physicalState.targetColor)
        local t = easeInOutQuad(eye.physicalState.colorProgress)
        eye.physicalState.color = colors.pack(
            lerp(r1, r2, t),
            lerp(g1, g2, t),
            lerp(b1, b2, t)
        )
    end
    
    -- Atualizar tamanho da pupila
    local targetPupilSize = config.emotions[eye.currentEmotion].pupilSize
    eye.physicalState.pupilSize = lerp(eye.physicalState.pupilSize, targetPupilSize, 0.1)
    
    -- Atualizar temporizador de emoção
    if eye.emotionTimer > 0 then
        eye.emotionTimer = eye.emotionTimer - 1
        if eye.emotionTimer <= 0 then
            -- Selecionar próxima emoção aleatória
            local emotions = {}
            local weights = {}
            local totalWeight = 0
            
            for emotion, settings in pairs(config.emotions) do
                table.insert(emotions, emotion)
                -- Peso base + ajuste para evitar ficar muito tempo na mesma emoção
                local weight = (emotion == eye.currentEmotion) and 5 or 10
                table.insert(weights, weight)
                totalWeight = totalWeight + weight
            end
            
            local r = math.random(totalWeight)
            local sum = 0
            for i, weight in ipairs(weights) do
                sum = sum + weight
                if r <= sum then
                    setEmotion(emotions[i])
                    break
                end
            end
        end
    end
end

local function updateEffects(dt)
    -- Atualizar efeito atual
    eye.effects.current:update()
    
    -- Transição entre efeitos
    if eye.effects.transition < 1 then
        eye.effects.transition = eye.effects.transition + dt * 0.2
        if eye.effects.transition >= 1 then
            eye.effects.current = eye.effects.next
            eye.effects.transition = 0
        end
    end
    
    -- Atualizar partículas de lágrimas
    if config.emotions[eye.currentEmotion].tearful then
        for _, tear in ipairs(eye.particles.tears) do
            if tear.active then
                tear.y = tear.y + tear.speed
                tear.life = tear.life - 1
                if tear.life <= 0 then
                    tear.active = false
                end
            elseif math.random() < config.emotions[eye.currentEmotion].tearRate then
                tear.active = true
                tear.x = math.random(-25, 25)
                tear.y = -20
                tear.speed = math.random(2, 5)
                tear.size = math.random(1, 3)
                tear.life = math.random(30, 60)
            end
        end
    end
    
    -- Atualizar veias
    if config.emotions[eye.currentEmotion].veins then
        for _, vein in ipairs(eye.particles.veins) do
            vein.pulse = (vein.pulse + 0.01) % 1
        end
    end
end

local function drawSclera()
    local openness = eye.physicalState.openness * (1 - eye.physicalState.blinkProgress)
    local width = math.floor(config.eye.baseWidth * openness)
    local height = math.floor(config.eye.baseHeight * openness)
    
    local scleraColor = config.eye.scleraColor
    local highlightColor = config.palette.emotions[eye.currentEmotion].highlight
    
    for y = -height, height do
        for x = -width, width do
            local ellipse = (x*x)/(width*width) + (y*y)/(height*height)
            if ellipse <= 1 then
                -- Efeito de veias para emoções como raiva
                if config.emotions[eye.currentEmotion].veins then
                    local veinIntensity = 0
                    for _, vein in ipairs(eye.particles.veins) do
                        local distToVein = math.sqrt((x - vein.x1)^2 + (y - vein.y1)^2)
                        if distToVein < 5 then
                            veinIntensity = math.max(veinIntensity, (1 - distToVein/5) * (0.3 + vein.pulse * 0.7))
                        end
                    end
                    
                    if veinIntensity > 0 then
                        local r, g, b = colors.unpack(scleraColor)
                        local vr, vg, vb = colors.unpack(config.palette.veins[1])
                        r = lerp(r, vr, veinIntensity * config.emotions[eye.currentEmotion].veinIntensity)
                        g = lerp(g, vg, veinIntensity * config.emotions[eye.currentEmotion].veinIntensity)
                        b = lerp(b, vb, veinIntensity * config.emotions[eye.currentEmotion].veinIntensity)
                        mon.setBackgroundColor(colors.pack(r, g, b))
                    else
                        mon.setBackgroundColor(scleraColor)
                    end
                else
                    -- Padrão normal com realces aleatórios
                    if math.random() < 0.1 and ellipse > 0.3 then
                        mon.setBackgroundColor(highlightColor)
                    else
                        mon.setBackgroundColor(scleraColor)
                    end
                end
                
                mon.setCursorPos(
                    centerX + x + eye.physicalState.shakeOffsetX,
                    centerY + y + eye.physicalState.shakeOffsetY
                )
                mon.write(" ")
            end
        end
    end
end

local function drawIris()
    if eye.physicalState.blinkProgress > 0.7 then return end
    
    local openness = eye.physicalState.openness * (1 - eye.physicalState.blinkProgress)
    local irisWidth = math.floor(config.eye.irisWidth * openness)
    local irisHeight = math.floor(config.eye.irisHeight * openness)
    local pupilSize = math.floor(config.eye.pupilBaseSize * eye.physicalState.pupilSize)
    
    -- Posição do olhar com tremor
    local lookX = eye.physicalState.lookX * 10 + eye.physicalState.shakeOffsetX * 2
    local lookY = eye.physicalState.lookY * 6 + eye.physicalState.shakeOffsetY * 2
    
    -- Desenhar íris
    for y = -irisHeight, irisHeight do
        for x = -irisWidth, irisWidth do
            local ellipse = (x*x)/(irisWidth*irisWidth) + (y*y)/(irisHeight*irisHeight)
            if ellipse <= 1 then
                -- Padrão radial da íris
                local distFromCenter = math.sqrt(x*x + y*y) / irisWidth
                local angle = math.atan2(y, x)
                local pattern = (math.sin(angle * 5 + distFromCenter * 10) + 1) / 2
                
                local r, g, b = colors.unpack(eye.physicalState.color)
                local highlight = config.palette.emotions[eye.currentEmotion].highlight
                local hr, hg, hb = colors.unpack(highlight)
                
                -- Adicionar variação de cor
                r = lerp(r, hr, pattern * 0.3)
                g = lerp(g, hg, pattern * 0.3)
                b = lerp(b, hb, pattern * 0.3)
                
                -- Escurecer bordas
                local edgeDarken = ellipse^2
                r = r * (1 - edgeDarken * 0.5)
                g = g * (1 - edgeDarken * 0.5)
                b = b * (1 - edgeDarken * 0.5)
                
                mon.setBackgroundColor(colors.pack(r, g, b))
                mon.setCursorPos(
                    math.floor(centerX + x + lookX),
                    math.floor(centerY + y + lookY)
                )
                mon.write(" ")
            end
        end
    end
    
    -- Desenhar pupila
    for y = -pupilSize, pupilSize do
        for x = -pupilSize, pupilSize do
            if (x*x)/(pupilSize*pupilSize) + (y*y)/(pupilSize*pupilSize) <= 1 then
                mon.setBackgroundColor(colors.black)
                mon.setCursorPos(
                    math.floor(centerX + x + lookX),
                    math.floor(centerY + y + lookY)
                )
                mon.write(" ")
            end
        end
    end
    
    -- Reflexo na íris
    local reflexX = math.floor(irisWidth * 0.3 + lookX)
    local reflexY = math.floor(-irisHeight * 0.2 + lookY)
    local reflexSize = math.floor(pupilSize * 0.7)
    
    for y = -reflexSize, reflexSize do
        for x = -reflexSize, reflexSize do
            if (x*x + y*y) <= reflexSize*reflexSize then
                mon.setBackgroundColor(colors.white)
                mon.setCursorPos(
                    math.floor(centerX + x + reflexX),
                    math.floor(centerY + y + reflexY)
                )
                mon.write(" ")
            end
        end
    end
end

local function drawTears()
    if not config.emotions[eye.currentEmotion].tearful then return end
    
    for _, tear in ipairs(eye.particles.tears) do
        if tear.active then
            local color = config.palette.tears[tear.size]
            mon.setBackgroundColor(color)
            
            for i = 0, tear.size do
                mon.setCursorPos(
                    math.floor(centerX + tear.x),
                    math.floor(centerY + tear.y + i)
                )
                mon.write(" ")
            end
        end
    end
end

local function drawDebugInfo()
    if not config.debugMode then return end
    
    mon.setBackgroundColor(colors.black)
    mon.setTextColor(colors.white)
    
    -- Informações básicas
    mon.setCursorPos(1, 1)
    mon.write("Emo: " .. eye.currentEmotion)
    mon.setCursorPos(1, 2)
    mon.write("FPS: " .. eye.stats.lastFPS)
    mon.setCursorPos(1, 3)
    mon.write("Next: " .. eye.emotionTimer)
    
    -- Barra de transição de emoção
    mon.setCursorPos(1, 5)
    mon.write("[")
    local barWidth = 20
    local filled = math.floor(barWidth * eye.emotionTransition)
    for i = 1, barWidth do
        mon.setCursorPos(1 + i, 5)
        if i <= filled then
            mon.write("=")
        else
            mon.write(" ")
        end
    end
    mon.write("]")
end

-- Loop principal
local lastTime = os.epoch("utc")
while true do
    local currentTime = os.epoch("utc")
    local deltaTime = (currentTime - lastTime) / 1000
    lastTime = currentTime
    
    -- Calcular FPS
    eye.stats.frameCount = eye.stats.frameCount + 1
    if currentTime - eye.stats.lastUpdate >= 1000 then
        eye.stats.lastFPS = eye.stats.frameCount
        eye.stats.frameCount = 0
        eye.stats.lastUpdate = currentTime
    end
    
    -- Limpar tela
    mon.setBackgroundColor(colors.black)
    mon.clear()
    
    -- Atualizar estado
    updateBlink(deltaTime)
    updateEyeMovement(deltaTime)
    updateEmotionTransition(deltaTime)
    updateEffects(deltaTime)
    
    -- Desenhar
    eye.effects.current:draw()
    drawSclera()
    drawIris()
    drawTears()
    drawDebugInfo()
    
    -- Controlar taxa de atualização
    local targetDelay = 1 / config.maxFPS
    local elapsed = (os.epoch("utc") - currentTime) / 1000
    local sleepTime = math.max(0, targetDelay - elapsed)
    sleep(sleepTime)
end
