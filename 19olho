local mon = peripheral.find("monitor")
if not mon then
    print("Nenhum monitor encontrado. Conecte um monitor!")
    return
end

-- Configurações de display
mon.setTextScale(0.5)
local w, h = mon.getSize()
local centerX, centerY = math.floor(w / 2), math.floor(h / 2)

--= Constantes e Configurações =--
local SETTINGS = {
    COLORS = {
        colors.white, colors.orange, colors.magenta, colors.lime,
        colors.cyan, colors.pink, colors.yellow, colors.green,
        colors.purple, colors.blue, colors.red, colors.brown
    },
    
    MODES = {
        NORMAL = "normal",
        RAINBOW_IRIS = "rainbowIris",
        DISCO = "discoBackground",
        EQUALIZER = "equalizer",
        WATERY = "watery",
        ANGRY = "angry",
        BLACKOUT = "blackout"
    },
    
    PROBABILITIES = {
        NORMAL = 0.85,       -- 85% tempo normal
        SPECIAL = 0.03,       -- 3% modo especial
        EMOTION = 0.01,       -- 1% emoção forte
        BLINK = 0.005         -- 0.5% de piscar
    },
    
    DURATIONS = {
        NORMAL = 200,         -- 20 segundos
        SPECIAL = 250,        -- 25 segundos
        EMOTION = 300         -- 30 segundos
    },
    
    PHYSICS = {
        TEAR_COUNT = 100,     -- Número de partículas de lágrima
        VEIN_COUNT = 50,      -- Número de veias
        EQUALIZER_BARS = 36   -- Barras do equalizador
    }
}

--= Estado do Olho =--
local STATE = {
    mode = SETTINGS.MODES.NORMAL,
    timer = 0,
    colorIndex = 1,
    blink = 0,
    lookX = 0,
    lookY = 0,
    tears = {},
    veins = {},
    equalizer = {},
    psychoEffect = 0,
    waterLevel = 0,
    lastUpdate = 0
}

--= Inicialização de Partículas =--
local function initializeParticles()
    -- Lágrimas
    for i = 1, SETTINGS.PHYSICS.TEAR_COUNT do
        STATE.tears[i] = {
            x = math.random(-35, 35),
            y = math.random(-25, 25),
            speed = math.random(1, 4),
            size = math.random(1, 3),
            active = false,
            bright = math.random() < 0.3
        }
    end

    -- Veias
    for i = 1, SETTINGS.PHYSICS.VEIN_COUNT do
        STATE.veins[i] = {
            x1 = math.random(-28, 28),
            y1 = math.random(-18, 18),
            x2 = math.random(-28, 28),
            y2 = math.random(-18, 18),
            width = math.random(1, 3)
        }
    end

    -- Equalizador
    for i = 1, SETTINGS.PHYSICS.EQUALIZER_BARS do
        STATE.equalizer[i] = {
            height = math.random(1, 5),
            speed = math.random(1, 3) / 10,
            phase = math.random() * math.pi * 2
        }
    end
end

initializeParticles()

--= Funções de Desenho =--
local function drawPixel(x, y, color)
    mon.setBackgroundColor(color)
    mon.setCursorPos(centerX + x, centerY + y)
    mon.write(" ")
end

local function drawEllipse(x, y, w, h, color)
    for dy = -h, h do
        for dx = -w, w do
            if (dx*dx)/(w*w) + (dy*dy)/(h*h) <= 1 then
                drawPixel(x + dx, y + dy, color)
            end
        end
    end
end

local function drawDiscoBackground()
    for y = -h/2, h/2 do
        for x = -w/2, w/2 do
            if (x*x)/(w*w/4) + (y*y)/(h*h/4) > 1 then
                local c = SETTINGS.COLORS[(STATE.colorIndex + x + y + math.floor(os.epoch()/200)) % #SETTINGS.COLORS + 1]
                drawPixel(x, y, c)
            end
        end
    end
end

local function drawEqualizer()
    local radius = math.max(w, h)/2 + 5
    local timeFactor = os.epoch() / 500
    
    for i, bar in ipairs(STATE.equalizer) do
        local angle = (i * 10) * (math.pi / 180)
        local x = math.floor(radius * math.cos(angle))
        local y = math.floor(radius * math.sin(angle))
        
        -- Movimento ondulante com fase única para cada barra
        bar.height = 3 + math.sin(timeFactor * bar.speed + bar.phase) * 4
        
        -- Desenhar barra
        local colorIndex = (i + math.floor(timeFactor*2)) % #SETTINGS.COLORS + 1
        drawPixel(x, y, SETTINGS.COLORS[colorIndex])
    end
end

local function drawSclera()
    local eyeOpen = 1 - STATE.blink
    local eyeWidth = math.floor(30 * eyeOpen)
    local eyeHeight = math.floor(20 * eyeOpen)
    
    -- Base branca
    drawEllipse(0, 0, eyeWidth, eyeHeight, colors.white)
    
    -- Efeitos especiais
    if STATE.mode == SETTINGS.MODES.ANGRY then
        -- Veias vermelhas
        for _, v in ipairs(STATE.veins) do
            local steps = math.max(math.abs(v.x2 - v.x1), math.abs(v.y2 - v.y1))
            for i = 0, steps do
                local x = v.x1 + (v.x2 - v.x1) * i / steps
                local y = v.y1 + (v.y2 - v.y1) * i / steps
                if (x*x)/(eyeWidth*eyeWidth) + (y*y)/(eyeHeight*eyeHeight) <= 1 then
                    drawPixel(math.floor(x), math.floor(y), colors.red)
                end
            end
        end
    elseif STATE.mode == SETTINGS.MODES.BLACKOUT then
        -- Olho fechando
        for y = -eyeHeight, eyeHeight do
            if y > eyeHeight/3 then
                for x = -eyeWidth, eyeWidth do
                    if (x*x)/(eyeWidth*eyeWidth) + (y*y)/(eyeHeight*eyeHeight) <= 1 then
                        drawPixel(x, y, colors.black)
                    end
                end
            elseif y > eyeHeight/4 then
                for x = -eyeWidth, eyeWidth do
                    if (x*x)/(eyeWidth*eyeWidth) + (y*y)/(eyeHeight*eyeHeight) <= 1 then
                        drawPixel(x, y, colors.gray)
                    end
                end
            end
        end
    elseif STATE.mode == SETTINGS.MODES.WATERY then
        -- Olho cheio d'água
        for y = -eyeHeight, eyeHeight do
            for x = -eyeWidth, eyeWidth do
                if (x*x)/(eyeWidth*eyeWidth) + (y*y)/(eyeHeight*eyeHeight) <= 1 then
                    if math.random() < 0.2 then
                        drawPixel(x, y, colors.lightBlue)
                    end
                    if y < -eyeHeight/2 and math.random() < STATE.waterLevel/10 then
                        drawPixel(x, y, colors.cyan)
                    end
                end
            end
        end
    end
end

local function drawIris()
    if STATE.blink > 0.7 then return end
    
    local irisColor = SETTINGS.COLORS[STATE.colorIndex]
    local pupilSize = 3
    
    -- Efeitos especiais
    if STATE.mode == SETTINGS.MODES.RAINBOW_IRIS then
        irisColor = SETTINGS.COLORS[(math.floor(os.epoch() / 150) % #SETTINGS.COLORS) + 1]
    elseif STATE.mode == SETTINGS.MODES.WATERY then
        irisColor = colors.blue
        pupilSize = 2
    end
    
    -- Posição do olhar
    local lookX = STATE.lookX * 10
    local lookY = STATE.lookY * 6
    
    -- Desenhar íris e pupila
    drawEllipse(lookX, lookY, 8, 6, irisColor)
    drawEllipse(lookX, lookY, pupilSize, pupilSize, colors.black)
end

local function drawTears()
    if STATE.mode ~= SETTINGS.MODES.WATERY then return end
    
    -- Atualizar nível d'água
    STATE.waterLevel = math.min(10, STATE.waterLevel + 0.1)
    
    -- Atualizar e desenhar lágrimas
    for _, t in ipairs(STATE.tears) do
        if t.active then
            t.y = t.y + t.speed
            if t.y > 30 then
                t.active = false
            else
                local tearColor = t.bright and colors.lightBlue or colors.blue
                for i = 0, t.size do
                    drawPixel(t.x, t.y + i, tearColor)
                end
            end
        elseif math.random() < 0.08 * STATE.waterLevel/10 then
            t.active = true
            t.x = math.random(-30, 30)
            t.y = -25
            t.speed = math.random(2, 5)
            t.size = math.random(1, 3)
            t.bright = math.random() < 0.3
        end
    end
    
    -- Reflexos na água
    if STATE.waterLevel > 5 then
        for _ = 1, math.floor(STATE.waterLevel * 2) do
            local x = math.random(-10, 10)
            local y = math.random(-5, 5)
            if (x*x)/100 + (y*y)/25 <= 1 then
                drawPixel(x, y, colors.white)
            end
        end
    end
end

--= Lógica de Atualização =--
local function updateState()
    local currentTime = os.epoch()
    if currentTime - STATE.lastUpdate < 100 then return end
    STATE.lastUpdate = currentTime
    
    -- Atualizar modo
    STATE.timer = STATE.timer - 1
    if STATE.timer <= 0 then
        if math.random() < SETTINGS.PROBABILITIES.NORMAL then
            STATE.mode = SETTINGS.MODES.NORMAL
            STATE.timer = SETTINGS.DURATIONS.NORMAL + math.random(-50, 50)
            STATE.waterLevel = 0
        else
            STATE.mode = SETTINGS.MODES[math.random(#SETTINGS.MODES)]
            STATE.timer = SETTINGS.DURATIONS.SPECIAL + math.random(-50, 50)
            if STATE.mode == SETTINGS.MODES.WATERY then
                STATE.timer = SETTINGS.DURATIONS.EMOTION
            end
        end
    end
    
    -- Piscar
    if math.random() < SETTINGS.PROBABILITIES.BLINK then
        STATE.blink = 0.3
    end
    if STATE.blink > 0 then
        STATE.blink = STATE.blink - 0.03
        if STATE.blink < 0 then STATE.blink = 0 end
    end
    
    -- Movimento do olhar
    if math.random() < 0.05 then
        STATE.lookX = STATE.lookX * 0.7 + (math.random() * 2 - 1) * 0.3
        STATE.lookY = STATE.lookY * 0.7 + (math.random() * 2 - 1) * 0.3
    end
    
    -- Rotação de cores
    STATE.colorIndex = (math.floor(currentTime / 500) % #SETTINGS.COLORS + 1
end

--= Loop Principal =--
local function main()
    while true do
        mon.setBackgroundColor(colors.black)
        mon.clear()
        
        updateState()
        
        -- Desenhar efeitos de fundo
        if STATE.mode == SETTINGS.MODES.DISCO then
            drawDiscoBackground()
        elseif STATE.mode == SETTINGS.MODES.EQUALIZER then
            drawEqualizer()
        end
        
        -- Desenhar olho
        drawSclera()
        drawIris()
        drawTears()
        
        sleep(0.1)
    end
end
