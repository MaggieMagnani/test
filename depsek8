--= INICIALIZAÇÃO =--
local mon = peripheral.find("monitor")
if not mon then
    print("Monitor não encontrado!")
    return
end

mon.setTextScale(0.5)
local w, h = mon.getSize()
local centerX, centerY = math.floor(w / 2), math.floor(h / 2)

--= CORES PSICODÉLICAS =--
local COLORS = {
    colors.red, colors.orange, colors.yellow,
    colors.green, colors.cyan, colors.blue,
    colors.purple, colors.magenta, colors.pink
}

--= CONFIGURAÇÕES DINÂMICAS (baseadas no tamanho do monitor) =--
local EYE_WIDTH = math.floor(w * 0.6)       -- 60% da largura do monitor
local EYE_HEIGHT = math.floor(h * 0.5)      -- 50% da altura do monitor
local IRIS_RADIUS = math.floor(EYE_HEIGHT * 0.4)  -- 40% da altura do olho
local PUPIL_RADIUS = math.floor(IRIS_RADIUS * 0.4) -- 40% do raio da íris
local MOVE_RADIUS_X = math.floor(EYE_WIDTH * 0.25)  -- 25% da largura do olho
local MOVE_RADIUS_Y = math.floor(EYE_HEIGHT * 0.25) -- 25% da altura do olho
local COLOR_CHANGE_INTERVAL = 2
local MOVE_CHANGE_INTERVAL = 0.4

--= ESTADO =--
local currentColor = colors.blue
local lastColorChange = os.clock()
local targetX, targetY = 0, 0
local eyeX, eyeY = 0, 0
local lastMoveChange = os.clock()

--= FUNÇÕES AUXILIARES =--
local function drawPixel(x, y, color)
    if x >= 1 and x <= w and y >= 1 and y <= h then
        mon.setCursorPos(x, y)
        mon.setBackgroundColor(color)
        mon.write(" ")
    end
end

local function drawEllipse(cx, cy, rx, ry, color)
    for dy = -ry, ry do
        local lineWidth = math.floor(rx * math.sqrt(1 - (dy * dy) / (ry * ry)))
        for dx = -lineWidth, lineWidth do
            local px, py = centerX + cx + dx, centerY + cy + dy
            if px >= 1 and px <= w and py >= 1 and py <= h then
                drawPixel(px, py, color)
            end
        end
    end
end

--= LOOP PRINCIPAL =--
while true do
    mon.setBackgroundColor(colors.black)
    mon.clear()

    -- Troca de cor
    if os.clock() - lastColorChange > COLOR_CHANGE_INTERVAL then
        currentColor = COLORS[math.random(#COLORS)]
        lastColorChange = os.clock()
    end

    -- Movimento do olho (dentro dos limites calculados)
    if os.clock() - lastMoveChange > MOVE_CHANGE_INTERVAL then
        targetX = math.random(-MOVE_RADIUS_X, MOVE_RADIUS_X)
        targetY = math.random(-MOVE_RADIUS_Y, MOVE_RADIUS_Y)
        lastMoveChange = os.clock()
    end

    -- Suaviza o movimento
    eyeX = eyeX + (targetX - eyeX) * 0.2
    eyeY = eyeY + (targetY - eyeY) * 0.2

    -- Desenha o olho (garantindo que não ultrapasse os limites)
    drawEllipse(0, 0, EYE_WIDTH, EYE_HEIGHT, colors.white)
    drawEllipse(eyeX, eyeY, IRIS_RADIUS, IRIS_RADIUS, currentColor)
    drawEllipse(eyeX, eyeY, PUPIL_RADIUS, PUPIL_RADIUS, colors.black)

    -- Reflexos (posicionamento proporcional)
    drawPixel(centerX + eyeX - math.floor(IRIS_RADIUS/2), centerY + eyeY - math.floor(IRIS_RADIUS/2), colors.white)
    drawPixel(centerX + eyeX - math.floor(IRIS_RADIUS/3), centerY + eyeY - math.floor(IRIS_RADIUS/3), colors.white)

    sleep(0.05)
end
