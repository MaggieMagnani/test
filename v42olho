--= OLHO EMOCIONAL REFINADO =--
-- Versão 4.1 - Sem piscar e com tamanho ajustado

--= CONFIGURAÇÃO INICIAL =--
local mon = peripheral.find("monitor")
if not mon then
    print("Monitor não encontrado!")
    return
end

mon.setTextScale(0.5)
local w, h = mon.getSize()
local centerX, centerY = math.floor(w / 2), math.floor(h / 2)

-- Ajuste de tamanho (1.3x maior que o original)
local SIZE_FACTOR = 1.3

--= FUNÇÕES ÚTEIS =--
local function lerp(a, b, t)
    return a + (b - a) * t
end

local function weightedRandom(weights)
    local total = 0
    for _, w in pairs(weights) do
        total = total + w
    end
    local r = math.random() * total
    local sum = 0
    for k, w in pairs(weights) do
        sum = sum + w
        if r <= sum then
            return k
        end
    end
end

--= SISTEMA DE EMOÇÕES =--
local EMOTIONS = {
    CALMO = {
        duration = {300, 500},
        iris = {color = "rainbow", size = math.floor(5 * SIZE_FACTOR)},
        sclera = {color = colors.white, redness = 0},
        effects = {particles = "none"}
    },
    TRISTE = {
        duration = {300, 400},
        iris = {color = colors.blue, size = math.floor(5 * SIZE_FACTOR)},
        sclera = {color = colors.lightBlue, redness = 0.1},
        effects = {particles = "tears", intensity = 0.7}
    },
    CHORANDO = {
        duration = {400, 500},
        iris = {color = colors.blue, size = math.floor(5 * SIZE_FACTOR)},
        sclera = {color = colors.lightBlue, redness = 0.3},
        effects = {particles = "tears", intensity = 1.0}
    },
    ASSUSTADO = {
        duration = {300, 400},
        iris = {color = colors.lightGray, size = math.floor(6 * SIZE_FACTOR)}, -- Pupila dilatada
        sclera = {color = colors.white, redness = 0.2},
        effects = {particles = "none"}
    },
    BRAVO = {
        duration = {300, 400},
        iris = {color = colors.red, size = math.floor(4 * SIZE_FACTOR)}, -- Pupila contraída
        sclera = {color = colors.red, redness = 0.5},
        effects = {particles = "none"}
    }
}

--= ESTADO DO OLHO =--
local eye = {
    emotion = "CALMO",
    timer = 300,
    look = {x = 0, y = 0, targetX = 0, targetY = 0},
    particles = {
        tears = {}
    }
}

--= INICIALIZAÇÃO DE PARTÍCULAS =--
for i = 1, 120 do
    eye.particles.tears[i] = {
        active = false,
        x = 0,
        y = 0,
        size = 1,
        speed = 1,
        color = colors.blue,
        life = 0
    }
end

--= FUNÇÕES DE DESENHO =--
local function drawPixel(x, y, color)
    local drawX = centerX + x
    local drawY = centerY + y
    if drawX >= 1 and drawX <= w and drawY >= 1 and drawY <= h then
        mon.setBackgroundColor(color)
        mon.setCursorPos(drawX, drawY)
        mon.write(" ")
    end
end

local function drawEllipse(x, y, rx, ry, color)
    local rx2 = rx * rx
    local ry2 = ry * ry
    for dy = -ry, ry do
        local dxLimit = math.sqrt(rx2 * (1 - (dy*dy)/ry2)
        for dx = -dxLimit, dxLimit do
            drawPixel(x + math.floor(dx), y + math.floor(dy), color)
        end
    end
end

--= SISTEMA DE LÁGRIMAS =--
local function updateTears(dt)
    local e = EMOTIONS[eye.emotion]
    if not e.effects.particles or e.effects.particles ~= "tears" then
        return
    end

    local intensity = e.effects.intensity or 0.5
    local spawnRate = lerp(0.5, 1.5, intensity) * dt

    for _, tear in ipairs(eye.particles.tears) do
        if tear.active then
            tear.y = tear.y + tear.speed * 60 * dt
            tear.life = tear.life - dt
            if tear.y > h / 2 or tear.life <= 0 then
                tear.active = false
            end
        elseif math.random() < spawnRate then
            tear.active = true
            tear.x = math.random(-30, 30)
            tear.y = -15 - math.random(5)
            tear.size = math.random(1, 3)
            tear.speed = math.random(15, 35) / 10 * intensity
            tear.life = math.random(2, 5)
            tear.color = ({colors.blue, colors.lightBlue, colors.cyan})[math.random(3)]
        end
    end
end

local function drawTears()
    local e = EMOTIONS[eye.emotion]
    if not e.effects.particles or e.effects.particles ~= "tears" then
        return
    end

    for _, tear in ipairs(eye.particles.tears) do
        if tear.active then
            -- Lágrima principal
            drawPixel(tear.x, tear.y, tear.color)
            
            -- Cauda da lágrima
            for i = 1, tear.size do
                drawPixel(tear.x, tear.y - i, tear.color)
            end
            
            -- Reflexo
            if math.random() < 0.3 then
                drawPixel(tear.x + math.random(-1,1), tear.y, colors.white)
            end
        end
    end
    
    -- Olho marejado quando chorando muito
    if e.effects.intensity > 0.7 then
        for i = 1, math.floor(e.effects.intensity * 15) do
            drawPixel(math.random(-25, 25), math.random(-10, 0), colors.lightBlue)
        end
    end
end

--= DESENHO DO OLHO =--
local function drawEye()
    local e = EMOTIONS[eye.emotion]
    
    -- Tamanhos ajustados
    local scleraW, scleraH = math.floor(26 * SIZE_FACTOR), math.floor(13 * SIZE_FACTOR)
    local irisSize = e.iris.size

    -- Desenhar esclera (parte branca do olho)
    drawEllipse(0, 0, scleraW, scleraH, e.sclera.color)

    -- Adicionar vermelhidão
    if e.sclera.redness > 0 then
        for i = 1, math.floor(e.sclera.redness * 100) do
            drawPixel(
                math.random(-scleraW, scleraW),
                math.random(-scleraH, scleraH),
                colors.red
            )
        end
    end

    -- Movimentar íris naturalmente
    if math.random() < 0.05 then
        eye.look.targetX = math.random(-8, 8)
        eye.look.targetY = math.random(-5, 5)
    end
    eye.look.x = lerp(eye.look.x, eye.look.targetX, 0.1)
    eye.look.y = lerp(eye.look.y, eye.look.targetY, 0.1)

    local irisX = math.floor(eye.look.x)
    local irisY = math.floor(eye.look.y)

    -- Cor da íris
    local irisColor = e.iris.color
    if irisColor == "rainbow" then
        local time = os.epoch() / 1000
        local hue = (time % 10) / 10
        if hue < 0.17 then irisColor = colors.red
        elseif hue < 0.33 then irisColor = colors.orange
        elseif hue < 0.5 then irisColor = colors.yellow
        elseif hue < 0.67 then irisColor = colors.green
        elseif hue < 0.83 then irisColor = colors.blue
        else irisColor = colors.purple end
    end

    -- Íris
    drawEllipse(irisX, irisY, irisSize, irisSize, irisColor)

    -- Pupila (tamanho varia com emoção)
    local pupilSize = irisSize * 0.4
    if eye.emotion == "ASSUSTADO" then pupilSize = irisSize * 0.6 end
    if eye.emotion == "BRAVO" then pupilSize = irisSize * 0.3 end
    
    drawEllipse(irisX, irisY, pupilSize, pupilSize, colors.black)

    -- Reflexo nos olhos
    drawEllipse(irisX - 2, irisY - 2, 2, 2, colors.white)
end

--= LOOP PRINCIPAL =--
local lastTime = os.epoch("utc")
while true do
    local currentTime = os.epoch("utc")
    local dt = (currentTime - lastTime) / 1000
    lastTime = currentTime

    -- Atualizar estado
    eye.timer = eye.timer - 1
    if eye.timer <= 0 then
        eye.emotion = weightedRandom({
            CALMO = 50,
            TRISTE = 15,
            CHORANDO = 10,
            ASSUSTADO = 15,
            BRAVO = 10
        })
        eye.timer = math.random(
            EMOTIONS[eye.emotion].duration[1],
            EMOTIONS[eye.emotion].duration[2]
        )
    end

    -- Atualizar sistemas
    updateTears(dt)

    -- Desenhar
    mon.setBackgroundColor(colors.black)
    mon.clear()

    drawEye()
    drawTears()

    sleep(0.05)  -- ~20 FPS
end
            end
            last_px, last_py = px, py
        end
    end
end


--= ATUALIZAÇÃO DE ESTADO DO OLHO =--
local function updateLook(dt)
    local look_speed = 1.8 -- Um pouco mais rápido
    local currentEmotionData = EMOTIONS[eye.emotion]
    local currentIrisSize = currentEmotionData.iris.size or 7

    eye.look.x = lerp(eye.look.x, eye.look.targetX, look_speed * dt)
    eye.look.y = lerp(eye.look.y, eye.look.targetY, look_speed * dt)

    eye.look.timer = eye.look.timer - dt
    if eye.look.timer <= 0 then
        local max_look_offset_x = SCLERA_RX_BASE - currentIrisSize - 3 -- margem
        local max_look_offset_y = SCLERA_RY_BASE - currentIrisSize - 3 -- margem
        if max_look_offset_x < 0 then max_look_offset_x = 0 end
        if max_look_offset_y < 0 then max_look_offset_y = 0 end

        eye.look.targetX = (math.random() * (max_look_offset_x * 2) - max_look_offset_x) * 0.8 -- Não olhar tão para as bordas
        eye.look.targetY = (math.random() * (max_look_offset_y * 2) - max_look_offset_y) * 0.8
        eye.look.timer = math.random(10, 40) / 10
    end
end

--= SISTEMAS DE PARTÍCULAS =--
local function updateTears(dt)
    local e_config = EMOTIONS[eye.emotion]
    if not (e_config.effects.particles:find("tear") or e_config.effects.particles:find("waterfall")) then return end

    local intensity = e_config.effects.intensity or 0.5
    if e_config.effects.particles == "waterfall" then
        intensity = math.min(1.0, intensity * 1.5)
    end
    
    local baseSpawnChancePerParticle = lerp(0.1, 0.5, intensity) 

    for _, tear in ipairs(eye.particles.tears) do
        if tear.active then
            tear.y = tear.y + tear.speed * 60 * dt
            tear.life = tear.life - dt
            if tear.y > centerY + SCLERA_RY_BASE + 10 or tear.life <= 0 then
                tear.active = false
            end
        elseif math.random() < baseSpawnChancePerParticle * dt then
            tear.active = true
            tear.x = math.random(math.floor(-SCLERA_RX_BASE*0.7), math.floor(SCLERA_RX_BASE*0.7))
            tear.y = math.random(-10, 10) + SCLERA_RY_BASE*0.1 -- Origem um pouco abaixo do centro vertical da íris
            tear.size = math.random(2, 5) -- Lágrimas um pouco maiores
            tear.speed = (math.random(25, 45)/10) * (0.5 + intensity*0.5)
            tear.life = math.random(2, 5) * (0.7 + intensity*0.3)
            tear.color = ({colors.blue, colors.lightBlue, colors.cyan})[math.random(3)]
        end
    end
end

local function drawTears()
    local e_config = EMOTIONS[eye.emotion]
    if not (e_config.effects.particles:find("tear") or e_config.effects.particles:find("waterfall")) then return end

    for _, tear in ipairs(eye.particles.tears) do
        if tear.active then
            local tearDrawX = eye.look.x + tear.x 
            local tearDrawY = eye.look.y + tear.y 
            for i = 0, tear.size -1 do -- Desenha uma linha vertical para a lágrima
                drawPixel(tearDrawX, tearDrawY - i, tear.color)
            end
            if math.random() < 0.15 then -- Reflexo um pouco mais sutil
                drawPixel(tearDrawX + math.random(-1,1), tearDrawY, colors.white)
            end
        end
    end

    if e_config.effects.intensity > 0.6 and (e_config.effects.particles == "tears" or e_config.effects.particles == "waterfall") then
        local waterShineY = SCLERA_RY_BASE * 0.8 + eye.look.y -- Mais abaixo
        for x_offset = -SCLERA_RX_BASE * 0.6, SCLERA_RX_BASE * 0.6 do
            if math.random() < 0.04 * e_config.effects.intensity then
                drawPixel(x_offset + eye.look.x, waterShineY + math.random(-1,1), colors.lightBlue)
            end
        end
    end
end

local function updateFloaters(dt)
    if EMOTIONS[eye.emotion].effects.particles ~= "floaters" then return end
    for _, floater in ipairs(eye.particles.floaters) do
        floater.x = floater.x + (math.random() * 1 - 0.5) * 30 * dt
        floater.y = floater.y + floater.speed * 40 * dt
        if floater.y > h/2 + 10 then floater.y = -h/2 - 10; floater.x = math.random(-w/2, w/2); end
        if floater.y < -h/2 -10 then floater.y = h/2 + 10; floater.x = math.random(-w/2, w/2); end
        if floater.x > w/2 + 10 then floater.x = -w/2 -10; end
        if floater.x < -w/2 -10 then floater.x = w/2 + 10; end
    end
end

local function drawFloaters()
    if EMOTIONS[eye.emotion].effects.particles ~= "floaters" then return end
    for _, floater in ipairs(eye.particles.floaters) do
        mon.setBackgroundColor(floater.color)
        mon.setCursorPos(math.floor(centerX + floater.x), math.floor(centerY + floater.y))
        mon.write(" ")
    end
end

-- Partículas para BRAVO
local function updateSparks(dt)
    if EMOTIONS[eye.emotion].effects.particles ~= "sparks" then return end
    local intensity = EMOTIONS[eye.emotion].effects.intensity or 0.5
    local spawnChance = 0.8 * intensity -- Maior chance de spawn

    for _, spark in ipairs(eye.particles.sparks) do
        if spark.active then
            spark.x = spark.x + spark.dx * 150 * dt -- Mais rápidas
            spark.y = spark.y + spark.dy * 150 * dt
            spark.life = spark.life - dt
            if spark.life <= 0 or math.abs(spark.x) > w/2 or math.abs(spark.y) > h/2 then
                spark.active = false
            end
        elseif math.random() < spawnChance * dt then
            spark.active = true
            spark.x = eye.look.x + (math.random() - 0.5) * EMOTIONS[eye.emotion].iris.size * 2
            spark.y = eye.look.y + (math.random() - 0.5) * EMOTIONS[eye.emotion].iris.size * 2
            local angle = math.random() * math.pi * 2
            spark.dx = math.cos(angle)
            spark.dy = math.sin(angle)
            spark.life = math.random(2, 6) / 10 -- Vida curta
            spark.color = ({colors.red, colors.orange, colors.yellow})[math.random(3)]
        end
    end
end

local function drawSparks()
    if EMOTIONS[eye.emotion].effects.particles ~= "sparks" then return end
    for _, spark in ipairs(eye.particles.sparks) do
        if spark.active then
            drawPixel(spark.x, spark.y, spark.color)
        end
    end
end

-- Partículas para PSICODELICO
local psychedelic_colors = {colors.red, colors.orange, colors.yellow, colors.lime, colors.cyan, colors.blue, colors.purple, colors.magenta, colors.pink, colors.white}
local function updateColorBursts(dt)
    if EMOTIONS[eye.emotion].effects.particles ~= "color_bursts" then return end
    local intensity = EMOTIONS[eye.emotion].effects.intensity or 0.5
    local spawnChance = 0.5 * intensity

    for _, burst in ipairs(eye.particles.color_bursts) do
        if burst.active then
            burst.radius = burst.radius + 30 * dt -- Cresce rápido
            burst.life = burst.life - dt
            burst.color_timer = burst.color_timer - dt
            if burst.color_timer <= 0 then
                burst.current_color_index = (burst.current_color_index % #burst.color_palette) + 1
                burst.color_timer = 0.05 -- Muda cor rápido
            end

            if burst.life <= 0 or burst.radius > burst.max_radius then
                burst.active = false
            end
        elseif math.random() < spawnChance * dt then
            burst.active = true
            burst.x = math.random(-w/2 + 10, w/2 - 10) -- Spawn em qualquer lugar
            burst.y = math.random(-h/2 + 10, h/2 - 10)
            burst.radius = 1
            burst.max_radius = math.random(15, 40) -- Tamanho máximo do burst
            burst.life = burst.max_radius / 30 + 0.1 -- Vida baseada em quão rápido cresce
            
            -- Paleta de cores aleatória para cada burst
            burst.color_palette = {}
            for _ = 1, math.random(3,5) do table.insert(burst.color_palette, psychedelic_colors[math.random(#psychedelic_colors)]) end
            burst.current_color_index = 1
            burst.color_timer = 0.05
        end
    end
end

local function drawColorBursts()
    if EMOTIONS[eye.emotion].effects.particles ~= "color_bursts" then return end
    for _, burst in ipairs(eye.particles.color_bursts) do
        if burst.active then
            local currentColor = burst.color_palette[burst.current_color_index]
            -- Desenha uma borda de elipse (círculo)
            drawEllipse(burst.x, burst.y, burst.radius, burst.radius * 0.7, currentColor, false) -- Elipse para variar
        end
    end
end


--= EFEITOS DE BACKGROUND =--
local spiral = {angle=0}
local function drawSpiralBackground(dt)
    spiral.angle = (spiral.angle + 0.7 * dt) % (math.pi*2)
    local layers = 7
    local maxRadius = math.max(w,h)/1.5 -- Espiral maior

    for l = 1, layers do
        local radius = (maxRadius/layers) * l
        local steps = math.floor(radius * 2)
        local color = psychedelic_colors[ (math.floor(os.clock()*2 + l) % #psychedelic_colors) + 1]

        for i = 0, steps do
            local a = spiral.angle * (l % 2 == 0 and 1 or -1) + (i/steps)*math.pi*2
            local x = math.floor(math.cos(a)*radius)
            local y = math.floor(math.sin(a)*radius * 0.6) 
            if i % math.max(1, math.floor(4+l*0.8)) == 0 then
                drawPixel(x, y, color)
            end
        end
    end
end

local function drawFogBackground()
    for _ = 1, 50 do -- Mais névoa para tela maior
        local x_abs = math.random(1, w)
        local y_abs = math.random(1, h)
        mon.setCursorPos(x_abs, y_abs)
        mon.setBackgroundColor(colors.gray)
        mon.write(" ")
    end
end

local function handleStormBackground(dt)
    if eye.storm_flash_timer > 0 then
        mon.setBackgroundColor(colors.white)
        mon.clear()
        eye.storm_flash_timer = eye.storm_flash_timer - dt
    elseif math.random() < 0.15 * dt then
         eye.storm_flash_timer = math.random(5,12)/100
    end
    -- Desenhar "chuva" (linhas verticais caindo)
    for _ = 1, 70 do -- Mais chuva
        local rainX = math.random(1, w)
        local rainYstart = math.random(1, h)
        local rainLen = math.random(2,5)
        local rainColor = colors.lightBlue
        if math.random() < 0.3 then rainColor = colors.blue end
        
        mon.setBackgroundColor(rainColor)
        for i=0, rainLen-1 do
            if rainYstart + i <= h then
                mon.setCursorPos(rainX, rainYstart + i)
                mon.write("|") -- Usar caractere para parecer chuva
            end
        end
    end
end

-- Background para BRAVO
local function drawShakyRedAuraBackground(dt)
    eye.shaky_aura_offset_x = (math.random() - 0.5) * 4 -- Aumentar o "shake"
    eye.shaky_aura_offset_y = (math.random() - 0.5) * 4

    local num_layers = 5
    local base_aura_color = colors.red
    for i = 1, num_layers do
        local radius_x = SCLERA_RX_BASE + i * 6 + (math.sin(os.clock()*3 + i) * 3) -- Pulsar
        local radius_y = SCLERA_RY_BASE + i * 6 + (math.sin(os.clock()*3 + i) * 3)
        
        local alpha = 1 - (i / num_layers) -- Mais transparente para fora
        local current_color
        if alpha > 0.66 then current_color = colors.red
        elseif alpha > 0.33 then current_color = colors.orange
        else current_color = colors.yellow
        end
        
        -- Desenha apenas a borda da elipse
        drawEllipse(eye.shaky_aura_offset_x, eye.shaky_aura_offset_y, radius_x, radius_y, current_color, false)
    end
end

-- Background para PSICODELICO
local function drawPsychedelicTunnelBackground(dt)
    eye.psychedelic_tunnel_offset = (eye.psychedelic_tunnel_offset + 60 * dt) % 20 -- Velocidade do "zoom"
    local num_layers = 8
    
    for i = num_layers, 1, -1 do -- Desenha de trás para frente
        local progress = (i * 20 - eye.psychedelic_tunnel_offset) / (num_layers * 20)
        if progress < 0 then progress = progress + 1 end -- Wrap around
        if progress > 1 then progress = progress - 1 end
        
        local radius_x = w * 0.8 * progress
        local radius_y = h * 0.8 * progress
        
        if radius_x < 2 or radius_y < 2 then goto next_layer end -- Pular se muito pequeno

        local color_index = math.floor(os.clock() * 5 + i * 2) % #psychedelic_colors + 1
        local current_color = psychedelic_colors[color_index]
        
        -- Desenhar retângulos concêntricos ou elipses
        -- drawEllipse(0,0, radius_x, radius_y, current_color, false) -- Elipses
        -- Ou retangulos:
        mon.setBackgroundColor(current_color)
        for x = -math.floor(radius_x), math.floor(radius_x) do
            drawPixel(x, -math.floor(radius_y), current_color)
            drawPixel(x,  math.floor(radius_y), current_color)
        end
        for y = -math.floor(radius_y), math.floor(radius_y) do
            drawPixel(-math.floor(radius_x), y, current_color)
            drawPixel( math.floor(radius_x), y, current_color)
        end
        ::next_layer::
    end
end


--= FUNÇÃO PRINCIPAL DE DESENHO DO OLHO =--
local function drawMainEye(emotionData, dt_arg)
    local e_iris_cfg = emotionData.iris
    local e_sclera_cfg = emotionData.sclera

    -- 1. Esclera
    drawEllipse(0, 0, SCLERA_RX_BASE, SCLERA_RY_BASE, e_sclera_cfg.color)

    -- 2. Veias (aprimoradas para BRAVO / redness alta)
    if e_sclera_cfg.redness > 0.05 then
        local num_vessels_base = math.floor(e_sclera_cfg.redness * 80) -- Mais vasos base
        local vessel_thickness = 1
        if eye.emotion == "BRAVO" then
            num_vessels_base = math.floor(e_sclera_cfg.redness * 150) -- MUITO mais vasos para BRAVO
            vessel_thickness = 2 -- Veias mais grossas
        end

        for _ = 1, num_vessels_base do
            local angle_start = math.random() * math.pi * 2
            -- Começa mais perto da íris ou no meio da esclera
            local dist_start_factor = math.random(e_iris_cfg.size*1.1, SCLERA_RX_BASE * 0.6) / SCLERA_RX_BASE
            
            local x1 = eye.look.x + math.cos(angle_start) * SCLERA_RX_BASE * dist_start_factor
            local y1 = eye.look.y + math.sin(angle_start) * SCLERA_RY_BASE * dist_start_factor * (SCLERA_RY_BASE/SCLERA_RX_BASE) -- Ajuste de proporção

            local num_segments = math.random(1, (eye.emotion == "BRAVO") and 4 or 2) -- Mais segmentos para BRAVO
            local current_x, current_y = x1, y1

            for seg = 1, num_segments do
                local angle_branch = angle_start + (math.random() - 0.5) * 1.5 -- Ângulo de ramificação
                local len_branch = math.random(SCLERA_RX_BASE * 0.15, SCLERA_RX_BASE * 0.4)
                
                local x2 = current_x + math.cos(angle_branch) * len_branch
                local y2 = current_y + math.sin(angle_branch) * len_branch * (SCLERA_RY_BASE/SCLERA_RX_BASE)

                -- Limitar x2, y2 para não sair muito da esclera
                local dist_to_center_sq = (x2^2)/(SCLERA_RX_BASE^2) + (y2^2)/(SCLERA_RY_BASE^2)
                if dist_to_center_sq > 1.1 then -- Se sair um pouco, puxa para dentro
                    local scale_back = 1 / math.sqrt(dist_to_center_sq) * 0.98
                    x2 = x2 * scale_back
                    y2 = y2 * scale_back
                end
                
                -- Desenhar linha com espessura
                if vessel_thickness == 1 then
                    drawLine(current_x, current_y, x2, y2, colors.red)
                else -- Espessura 2 (desenha duas linhas próximas)
                    drawLine(current_x, current_y, x2, y2, colors.red)
                    drawLine(current_x+math.cos(angle_branch+math.pi/2), current_y+math.sin(angle_branch+math.pi/2), 
                             x2+math.cos(angle_branch+math.pi/2), y2+math.sin(angle_branch+math.pi/2), colors.red)
                end
                current_x, current_y = x2, y2
                angle_start = angle_branch -- Próximo segmento continua do ângulo do anterior
            end
        end
    end

    -- 3. Íris
    local irisColor = e_iris_cfg.color
    local time_factor = os.clock()
    if irisColor == "rainbow" then
        local rainbowPalette = {colors.red, colors.orange, colors.yellow, colors.green, colors.blue, colors.purple, colors.magenta}
        irisColor = rainbowPalette[math.floor(time_factor*1.8 % #rainbowPalette) + 1]
    elseif irisColor == "swirling" then
        local swirlPalette = {colors.cyan, colors.purple, colors.lime, colors.pink, colors.yellow}
        irisColor = swirlPalette[math.floor(time_factor*6 % #swirlPalette) + 1]
    elseif irisColor == "swirling_fast" then -- Para PSICODELICO
        irisColor = psychedelic_colors[math.floor(time_factor*20 % #psychedelic_colors) + 1]
    end
    local irisRadius = e_iris_cfg.size
    drawEllipse(eye.look.x, eye.look.y, irisRadius, irisRadius * (SCLERA_RY_BASE/SCLERA_RX_BASE), irisColor) -- Íris elíptica

    -- 4. Pupila
    local pupilBaseRadius = irisRadius * (e_iris_cfg.pupilScale or 0.4)
    local pupilRadiusX = math.max(1, pupilBaseRadius)
    local pupilRadiusY = math.max(1, pupilBaseRadius * (SCLERA_RY_BASE/SCLERA_RX_BASE)) -- Pupila elíptica
    drawEllipse(eye.look.x, eye.look.y, pupilRadiusX, pupilRadiusY, colors.black)
end


--= LOOP PRINCIPAL =--
local lastTime = os.clock()
eye.look.timer = 0

while true do
    local currentTime = os.clock()
    local dt = currentTime - lastTime
    if dt == 0 then dt = 0.001 end -- Evitar dt zero que pode quebrar algumas lógicas
    lastTime = currentTime

    -- ATUALIZAR ESTADO
    eye.timer = eye.timer - (dt * 20)
    if eye.timer <= 0 then
        eye.emotion = weightedRandom({
            CALMO=40, TRISTE=15, CHORANDO=10, EMBRIAGADO=10, BRAVO=15, PSICODELICO=10 -- Pesos ajustados
        })
        local new_emotion_cfg = EMOTIONS[eye.emotion]
        eye.timer = math.random(new_emotion_cfg.duration.min, new_emotion_cfg.duration.max)
        eye.storm_flash_timer = 0
    end

    updateLook(dt)
    updateTears(dt)
    updateFloaters(dt)
    updateSparks(dt) ------ NOVO
    updateColorBursts(dt) -- NOVO

    -- DESENHAR
    local currentEmotionData = EMOTIONS[eye.emotion]

    -- 1. Fundo base
    local baseBgColor = colors.black
    if currentEmotionData.effects.bg == "storm" then baseBgColor = colors.darkGray end
    mon.setBackgroundColor(baseBgColor)
    mon.clear()

    -- 2. Efeitos de BG
    if currentEmotionData.effects.bg == "spiral" then drawSpiralBackground(dt)
    elseif currentEmotionData.effects.bg == "fog" then drawFogBackground()
    elseif currentEmotionData.effects.bg == "shaky_red_aura" then drawShakyRedAuraBackground(dt) -- NOVO
    elseif currentEmotionData.effects.bg == "psychedelic_tunnel" then drawPsychedelicTunnelBackground(dt) -- NOVO
    end
    
    if currentEmotionData.effects.bg == "storm" then
        handleStormBackground(dt)
        if eye.storm_flash_timer > 0 then
            sleep(math.max(0, 0.05 - (os.clock() - currentTime)))
            goto continue_loop
        end
    end

    -- 3. Olho principal
    drawMainEye(currentEmotionData, dt)

    -- 4. Partículas sobre o olho
    drawTears()
    drawFloaters()
    drawSparks() ------ NOVO
    drawColorBursts() -- NOVO

    sleep(math.max(0, 0.05 - (os.clock() - currentTime))) -- Tentar manter ~20 FPS
    ::continue_loop::
end
